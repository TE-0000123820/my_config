#
# types
#
snippet ib "int8_t" w
int8_t
endsnippet

snippet ih "int16_t" w
int16_t
endsnippet

snippet il "int32_t" w
int32_t
endsnippet

snippet ill "int64_t" w
int64_t
endsnippet

snippet uib "uint8_t" w
uint8_t
endsnippet

snippet uih "uint16_t" w
uint16_t
endsnippet

snippet uil "uint32_t" w
uint32_t
endsnippet

snippet uill "uint64_t" w
uint64_t
endsnippet

snippet co "const" w
const
endsnippet

snippet un "unsigned" w
unsigned
endsnippet

#
# fmt
#
snippet pf "%f" w
%f
endsnippet

snippet pd "%d" w
%d
endsnippet

snippet ps "%s" w
%s
endsnippet

snippet px "0x%x" w
0x%x
endsnippet

#
# other
#
snippet an "&" w
&
endsnippet

snippet aa "&&" w
&& 
endsnippet

snippet or "|" w
|
endsnippet

snippet oo "||" w
|| 
endsnippet

snippet se "#endif" w
#endif
endsnippet

snippet si "#ifdef" w
#ifdef DEBUG
endsnippet

snippet /* "/**/" w
/* $1 */
endsnippet

snippet sb "soft_break()" w
soft_break(1);
endsnippet

snippet el "else" w
else {
    $1
}
endsnippet

snippet if
if(${1:true}) {
    ${0:${VISUAL}}
}
endsnippet

snippet ifh "if half"
if(${1:true}) {
endsnippet

snippet ife
if(${1:true}) {
    ${2:${VISUAL}}
} else {
    ${0}
}
endsnippet

snippet fwrite "int wlen = fwrite(out, 1, sizeof(out), ,fp); assert(wlen == sizeof(out) && 'fwrite');"
int wlen = fwrite(out, 1, sizeof(out), ,fp);
assert(wlen == sizeof(out) && "fwrite");
endsnippet

snippet fwritel "FILE* fp = fopen('out.bin', 'w'); assert(fp); int rv = fwrite(out, sizeof(out) ,1 ,fp); assert(rv == 1);"
{
    FILE* fp = fopen("out.bin", "w");
    assert(fp && "fopen write");
	int wlen = fwrite(out, 1, sizeof(out), ,fp);
	assert(wlen == sizeof(out) && "fwrite");
	fclose(fp);
}
endsnippet

# for
snippet for
for(int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
    ${4}
}
endsnippet

snippet forh "for half"
for(int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
endsnippet

snippet fore "for(const auto& itr :: container) { }"
for(const auto& ${1:itr} : ${2:container}) {
	${3}
}
endsnippet

snippet foree "for(auto& itr :: container) { }"
for(auto& ${1:itr} : ${2:container}) {
	${3}
}
endsnippet

snippet spr "saprintf()" w
saprintf("$1\n"$2);
endsnippet

snippet dp "DEBUGPRINT()" w
DEBUGPRINT("$1\n"$2);
endsnippet

snippet pr "printf()" w
printf("$1\n"$2);
endsnippet

snippet sonyh "sony header comment"
/*
 * Sony CONFIDENTIAL
 *
 * Copyright 2016 Sony Corporation
 *
 * DO NOT COPY AND/OR REDISTRIBUTE WITHOUT PERMISSION.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
endsnippet


snippet st "start timer"
start_timer(${1:0});
endsnippet

snippet et "stop timer"
stop_timer(${1:0});
endsnippet

snippet len "sizeof(${1:array})/sizeof(${2:array[0]})" w
sizeof(${1:array})/sizeof(${2:array[0]})
endsnippet

snippet hp "printf('o: 0x%x\n', ${1:_0});" w
printf("o: 0x%x\n", ${1:_0});
endsnippet

snippet sagetdma "get_data_dma1(dst, src, size)" w
get_data_dma1(dst, src, size)
endsnippet

snippet sasetdmaall "set_listadr_dma1(dmalist); set_dmalist_read(&dmalist[list_idx++], dst, src, len); set_dmalist_endcode(&dmalist[list_idx++]); start_dma1(); wait_dma1();" w
set_listadr_dma1(dmalist);
set_dmalist_read(&dmalist[list_idx++], dst, src, len);
set_dmalist_endcode(&dmalist[list_idx++]);
start_dma1();
wait_dma1();
endsnippet

snippet sagetdmarect "void get_rect_data_dma1(void *dst_addr, void *src_addr, uint32_t dst_width, uint32_t dst_height, uint32_t dst_xofst, uint32_t src_width, uint32_t src_height, uint32_t src_xofst)" w
get_rect_data_dma1(void *dst_addr, void *src_addr, uint32_t dst_width, uint32_t dst_height, uint32_t dst_xofst, uint32_t src_width, uint32_t src_height, uint32_t src_xofst)
endsnippet

snippet sasetdmalistreadrect "void set_dmalist_read_rect(dmalist_t *listp, void *dst_addr, void *src_addr, uint32_t dst_width, uint32_t dst_height, uint32_t dst_xofst, uint32_t src_width, uint32_t src_height, uint32_t src_xofst)" w
void set_dmalist_read_rect(listp, dst_addr, src_addr, dst_width, dst_height, dst_xofst, src_width, src_height, src_xofst);
endsnippet

snippet fopr "FILE* fp = fopen('in.bin', 'r');"
FILE* fp = fopen("in.bin", "r");
assert(fp && "fopen read");
endsnippet

snippet fopw "FILE* fp = fopen('out.bin', 'w');"
FILE* fp = fopen("out.bin", "w");
assert(fp && "fopen write");
endsnippet

snippet fread "int rlen = fread(buff, 1, sizeof(buff), fp);"
int rlen = fread(buff, 1, sizeof(buff), fp);
assert(rlen == sizeof(buff) && "fread");
endsnippet

snippet freadl "FILE* fp = fopen('in.bin', 'r'); int rlen = fread(buff, 1, sizeof(buff), fp);"
{
	FILE* fp = fopen("in.bin", "r");
	assert(fp && "fopen read");
	int rlen = fread(buff, 1, sizeof(buff), fp);
	assert(rlen == sizeof(buff) && "fread");
	fclose(fp);
}
endsnippet

snippet prd "printf('%s:%s:%d: \n', __FILE__, __FUNCTION__, __LINE__);"
printf("%s:%s:%d: ${1}\n", __FILE__, __FUNCTION__, __LINE__);
endsnippet

snippet prk "printk('%s:%s:%d: \n', __FILE__, __FUNCTION__, __LINE__);"
printf("%s:%s:%d: ${1}\n", __FILE__, __FUNCTION__, __LINE__);
endsnippet

snippet prcr "color, red, printf('\x1b[31m');"
printf("\x1b[1m\x1b[31m");
printf("\x1b[0m");
endsnippet

snippet prcy "color, yellow, printf('\x1b[33m');"
printf("\x1b[1m\x1b[33m");
printf("\x1b[0m");
endsnippet

snippet prcm "color, magenta, printf('\x1b[35m');"
printf("\x1b[35m");
endsnippet

snippet prcc "color, clear, printf('\x1b[0m');"
printf("\x1b[0m");
endsnippet

snippet dumpbuff "unsigned char*p = (unsigned char*)${1}; for(int i = 0; i < ${2:100}; i++) { printf('o: 0x%02x\n', *p++); }"
{
	unsigned char*p = (unsigned char*)${1};
	for(int i = 0; i < ${2:100}; i++) {
		printf("o: 0x%02x\n", *p++);
	}
}
endsnippet

snippet viewdmalist "view_dmalists(UNUSED dmalist_t *listp)"
view_dmalists(${0:0});
endsnippet

snippet ofstream "std::ofstream f(filename, std::ios_base::out);"
{
	std::ofstream f(filename, std::ios_base::out);
	assert(!f.fail() && "Error: fopen");
	f << "${0}";
	f.close();
}
endsnippet

#
# opencl
#
snippet clgetbuildinfo "log,dump,clGetProgramBuildInfo" w
{
	cl_device_id di = deviceID;
	printf("e: %d\n", ret);
	// Determine the size of the log
	size_t log_size;
	clGetProgramBuildInfo(program, di, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size);
	// Allocate memory for the log
	char *log = (char *) malloc(log_size);
	// Get the log
	clGetProgramBuildInfo(program, di, CL_PROGRAM_BUILD_LOG, log_size, log, NULL);
	// Print the log
	printf(">>> %s\n", log);
}
endsnippet

snippet gdbint0 "gdb,int,set_trace,break,raise(SIGTRAP);" w
#include <signal.h>
raise(SIGTRAP);
endsnippet

snippet gdbint1 "gdb,int,set_trace,break,x86,__asm__('int3');" w
__asm__("int3");
endsnippet

snippet clprint "ClPrint(amd::LOG_DEBUG, amd::LOG_ALWAYS, 'dbgmsg');" w
ClPrint(amd::LOG_DEBUG, amd::LOG_ALWAYS, "dbgmsg\n");
endsnippet

snippet mybacktrace "mybacktrace,execinfo" w
#include <execinfo.h>
static void my_backtrace() {
    std::vector<void*> traces(10);
    int size = backtrace(traces.data(), traces.size());
    auto symbols = backtrace_symbols(traces.data(), size);
    std::vector<std::string> result(symbols, symbols+size);
    for(int i = 0; i < result.size(); i++) {
        printf("%d: %s\n", i, result[i].c_str());
    }
    free(symbols);
}
endsnippet

snippet mybacktraceunwind "mybacktrace,execinfo,unwind" w
#include <libunwind.h>
void do_backtrace()
{
    unw_cursor_t    cursor;
    unw_context_t   context;

    unw_getcontext(&context);
    unw_init_local(&cursor, &context);

    while (unw_step(&cursor) > 0)
    {
        unw_word_t  offset, pc;
        char        fname[64];

        unw_get_reg(&cursor, UNW_REG_IP, &pc);

        fname[0] = '\0';
        (void) unw_get_proc_name(&cursor, fname, sizeof(fname), &offset);

        printf ("%p : (%s+0x%x) [%p]\n", pc, fname, offset, pc);
    }
}
endsnippet
